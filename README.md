**開発ログ**

Phase 1: 基本設計とバックエンド基盤の構築 (2025年7月中旬)
 
- 技術選定: 

 バックエンドには、迅速な開発と堅牢性を両立できるPythonのDjangoフレームワーク、及びAPI開発を効率化するDjango REST Frameworkを選定。フロントエンドには、コンポーネントベースの開発でUI/UXを柔軟に構築できるReactを採用する方針を固めた。
 
- データベース設計: 
  
  アプリケーションの中核となる食事記録 (MealRecord)、体重記録 (WeightRecord) モデルを設計。Django標準のUserモデルと関連付け、ユーザーごとのデータ管理の基盤を構築した。
 
- 環境構築: 

  Python仮想環境 (venv) を設定し、プロジェクトの依存関係を分離。APIキーなどの秘匿情報はpython-dotenvを用いて.envファイルで管理し、セキュリティを確保した。
 
Phase 2: コアAPIの実装と認証システムの導入 (2025年7月中旬)

- CRUD APIの実装: 
 
  ModelViewSetとModelSerializerを活用し、食事記録と体重記録に対する基本的なCRUD (作成・読み取り・更新・削除) APIを実装。

- 認証機能の実装: 
 
  ステートレスなReactフロントエンドとの連携を容易にするため、DRFのトークン認証 (TokenAuthentication) を採用。パスワードのハッシュ化を自動で行うUser.objects.create_userを用いたユーザー登録API、及び認証トークンを発行するログインAPIを構築した。
  
- アクセス制御の実装: 
 
  全てのAPIエンドポイントにIsAuthenticatedパーミッションを設定。さらに、get_querysetメソッドをオーバーライドしてリクエストユーザーでデータをフィルタリングすることで、ユーザー間でデータが完全に分離されている状態を保証し、セキュリティを強化した。
 
Phase 3: フロントエンド環境構築とAPI連携 (2025年7月下旬)

- フロントエンド基盤構築: 
  
  モダンな開発環境であるViteを用いてReact開発環境を構築。
  
- APIクライアントの設定: 
  
  API通信ライブラリとしてaxiosを導入。localStorageに保存された認証トークンを、全てのリクエストヘッダーに自動で付与するaxiosインターセプターを設定し、認証が必要なリクエストの管理を効率化した。
  
- 接続課題の解決: 
  
  開発初期に発生したCORS (クロスオリジンリソース共有) エラーに対し、バックエンドのdjango-cors-headersライブラリの設定（許可するオリジン、ヘッダーの指定）を適切に行うことで解決した。
  
Phase 4: フロントエンドの主要機能実装 (2025年7月下旬)

- 認証フローの実装: 

 ユーザー登録、ログイン、ログアウト機能を持つReactコンポーネントを作成。ログイン状態をlocalStorageのトークンの有無で管理し、認証状態に応じて表示コンポーネントを切り替える条件付きレンダリングを実装した。

- CRUDインターフェースの実装: 
  
 ダッシュボード画面に、食事記録と体重記録の作成フォーム及び一覧表示機能を実装。記録の作成・更新・削除が実行された際に、ページをリロードすることなくUIが即座に更新されるよう、ReactのStateを適切に管理するロikkuを構築した。
  
- 更新機能のUI実装: 
  
 食事記録の更新機能として、ウィンドウ形式の編集フォームを実装。ユーザー体験を損なうことなく、データの編集を行えるようにした。
  
Phase 5: 高度なロジックの実装とデバッグ (2025年7月下旬)
  
- データ更新ロジックの改良: 
 
 体重記録において、ユーザーが同日に複数回記録した場合にデータが重複しないよう、バックエンドのViewSetにおけるcreateメソッドを修正、DjangoのORMが提供するupdate_or_createメソッドを利用した。

- 原因不明の400エラー: 

 上記update_or_createを実装する前段階で、正常に動作する食事記録APIとコード上は同一に見える体重記録APIだけが一貫してバリデーションエラーを返す問題に直面。体系的なデバッグ（コード比較、ランタイム検証、仮説構築・検証）の結果、モデルに設定したunique_for_date制約が、意図せずModelSerializerのバリデーション挙動に影響を与えていることを特定。この制約をアプリケーションの仕様に合わせて削除することで解決した。

- フロントエンドの表示不整合: 
  
 バックエンドのデータ更新後、フロントエンドのリスト表示が重複する問題をDuplicate Key警告から特定。State更新ロジックが「更新」を考慮しておらず、常に「追加」を行っていたことが原因であったため、条件付きの置換または追加を行うロジックに修正した。

